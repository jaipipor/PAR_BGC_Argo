function [PAR,PAR_b,ep50,IQR_ep] = PAR_from_Ed_380_490_555_665_v5(Ed,z)
%
% PAR predictor from multispectral Ed at the bands [380 490 555 665]
% Vectorized code, works with N samples at once, and returns N PAR
% estimates.
%
% [PAR,PAR_b,ep50,IQR_ep] = PAR_from_Ed_380_490_555_665_v5(Ed,z)
% Input arguments:
%   Ed  Nx4 matrix: downwelling irradiance spectrum
%   z   Nx1 matrix: depth (m)
% Output arguments:
%   PAR     Nx1 matrix: Best PAR estimate
%   PAR_b   Nx1 matrix: PAR with some remaining biases to be corrected with ep50
%   ep50    Nx1 matrix: Estimated median percent error of the output value, as a function of depth
%   IQR_ep  Nx1 matrix: Estimated interquartile range of the percent error of the output value, as a function of depth
% where N is the number of samples.
%
% This function is self-contained.
% Jaime Pitarch, CNR-ISMAR, 08-May-2025.

% Example run:
% my_Ed =[0.72199       1.6553       1.6139       1.0218
%         0.0021873     0.062225    0.0052865     1.7514e-05
%         0.079935      0.45121      0.32895      0.0012265];
% z=[ 0.7
%    74.4
%    16.4];
%    [PAR,PAR_b,ep50,IQR_ep] = PAR_from_Ed_380_490_555_665_v5(Ed,z);


% ===== NEURAL NETWORK CONSTANTS =====

% Input 1
x1_step1.xoffset = [-22.6422533091432;-7.62188447185006;-21.2406406116215;-22.1732499446457];
x1_step1.gain = [0.0862100486323673;0.233748143539256;0.0903196568208667;0.0872091412720763];
x1_step1.ymin = -1;

% Layer 1
b1 = [1.3773464153038603719;3.934717931881863251;0.52675095292634865896;-0.10299073255373906999;-1.098891162818485645;1.0545142766089230513;-0.64538664072691687146;0.39854275393886368084;-2.0068504080442410853;3.4287637416258429646];
IW1_1 = [-0.29134625456595830695 -2.352247775075971159 -0.23988589933927972897 1.6349723708078853779;0.31283190732449889238 1.5218017803267791521 -4.9466115392924852046 0.073019394319042599251;-1.0110443127012016529 -1.7831903035187097739 1.4100745497236202297 1.2333845810950849753;0.34453970755045482122 1.7859966959649229423 -0.084401439196087613137 -0.59812661340320993908;1.742021793990166989 -2.0002374236844526756 -1.4020409467087877609 0.6586906022553369322;-6.3820912642481779642 0.5353260563131788663 6.6667201829568156768 -1.0338245525385805212;1.523843466565415472 -0.43732011898881772982 0.20947299211361555815 3.5081512898236546505;1.5884843318685439861 -2.1761792882986847886 -2.4378150914911125291 -0.65702103674302758662;-0.74841850626434702765 1.1773296250078351122 3.0402833485572289263 -1.6241807390924207777;1.1358252828179440375 0.39215750910377827898 1.6790144905005168763 -4.9802969177871201367];

% Layer 2
b2 = 1.5399787796826152064;
LW2_1 = [-1.3142932341237907323 -0.95142756846376530522 0.91657977379205202162 0.69990615325192007123 -0.50040495690264430451 -0.1370257908912806688 0.19501202293220704087 0.14954303973742777423 -0.69502750373713040322 -1.2677926646034007874];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 0.250728512194969;
y1_step1.xoffset = -3.99369680999518;

% ===== SIMULATION ========

x1=log10(Ed);

% Dimensions
Q = size(x1,1); % samples

% Input 1
x1 = x1';
xp1 = mapminmax_apply(x1,x1_step1);

% Layer 1
a1 = tansig_apply(repmat(b1,1,Q) + IW1_1*xp1);

% Layer 2
a2 = repmat(b2,1,Q) + LW2_1*a1;

% Output 1
y1 = mapminmax_reverse(a2,y1_step1);
PAR_b = 10.^y1';
mat=[  0.1         -3.7386      0.81093
       0.2122      -3.3655      0.83813
      0.23809      -3.0734       1.1184
      0.26715      -2.7456       1.4328
      0.29974      -2.3778       1.7855
      0.33632      -2.5827       1.6887
      0.37735      -2.8126       1.5801
       0.4234      -3.0706       1.4582
      0.47506      -2.6888        1.493
      0.53303      -2.4966       1.4733
      0.59807       -2.281       1.4511
      0.67104      -2.2564       1.3994
      0.75292      -1.9559       1.4315
      0.84479      -1.6186       1.4675
      0.94787        -1.49      0.85171
       1.0635      -1.0293      0.76307
       1.1933      -1.1257      0.75985
       1.3389     -0.47736       1.1322
       1.5023    -0.077835         1.94
       1.6856     -0.49583       1.6567
       1.8913      0.08395       1.1179
        2.122      0.45883      0.92605
       2.3809      0.73549       1.2375
       2.6715       1.0404       1.0683
       2.9974       1.0627      0.88337
       3.3632       1.0408      0.92075
       3.7735       1.2251      0.94419
        4.234       1.2941      0.94618
       4.7506       1.2296       1.0103
       5.3303       1.0726       1.0602
       5.9807        0.771      0.94917
       6.7104      0.52638      0.99797
       7.5292      0.18161      0.98175
       8.4479     -0.16693      0.86562
       9.4787     -0.41726      0.82827
       10.635     -0.57626      0.84045
       11.933     -0.61061      0.79922
       13.389     -0.62086        0.856
       15.023     -0.55187       1.0413
       16.856     -0.35671       1.2344
       18.913     -0.22218       1.2702
        21.22    -0.085756       1.4414
       23.809   -0.0039399       1.4868
       26.715    -0.058402       1.4959
       29.974    -0.085731       1.6772
       33.632    -0.048984       1.8299
       37.735     -0.12471       2.1584
        42.34     -0.18625       2.1244
       47.506     -0.26989       2.5215
       53.303     -0.23538       2.8674
       59.807     -0.12665       3.0497
       67.104     0.036652       3.2778
       75.292      0.25315       3.3009
       84.479      0.29168       3.2199
       94.787     0.050012       2.9597
       106.35     0.085327       3.2845
       119.33      0.52048       4.0777
       133.89      0.87175       4.8183
       150.23      0.73795       5.1978
       168.56      0.48548       7.1637
       189.13      -1.1529       8.9553
       201             0            0
       1000            0            0];

ep50=interp1(log10(mat(:,1)),mat(:,2),log10(z));
IQR_ep=interp1(log10(mat(:,1)),mat(:,3),log10(z));

PAR=PAR_b./(1+ep50/100);
end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
